{"version":3,"file":"component---src-pages-blog-mdx-fields-slug-tsx-content-file-path-content-portfolio-grindlists-index-mdx-2757bc2bbd0cc388dc71.js","mappings":"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","sources":["webpack://portfolio-gatsby/./content/portfolio/grindlists/index.mdx","webpack://portfolio-gatsby/./src/pages/blog/{mdx.fields__slug}.tsx","webpack://portfolio-gatsby/./src/components/seo.tsx","webpack://portfolio-gatsby/./src/hooks/useSiteMetadata.ts","webpack://portfolio-gatsby/./node_modules/.pnpm/@mdx-js+react@2.3.0_react@18.2.0/node_modules/@mdx-js/react/lib/index.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    a: \"a\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.p, null, \"Grindlists is a web application designed to help gamers organize their grinding\\nsessions. For any readers who don't know what that means, sometimes a game\\nrequires a player to collect materials to complete a quest or craft an item.\\nSometimes those items also require crafting intermediate items, and it can be a\\nlot to keep track of. The goal of Grindlists is to help gamers keep track of\\nwhat items they need, how many they need, and where those items can be found.\"), \"\\n\", React.createElement(_components.p, null, \"Grindlists is comprised of a React Frontend and a GraphQL backend. It currently\\nuses JWT token-based authentication (with plans to implement OAuth support), a\\nPostgresQL database for storage, and a Redis server for caching. The main thing\\nI experimented with when building this project is code generators, which I will\\nelaborate on below.\"), \"\\n\", React.createElement(_components.p, null, \"The Backend for Grindlists is written in Go. The GraphQL server was generated\\n\", React.createElement(_components.a, {\n    href: \"https://gqlgen.com/\"\n  }, \"gqlgen\"), \", which handles most of the boilerplate code for you, but leaves the\\nnon-trivial resolvers (basically anything that needs to interact with the database)\\nfor the developer to implement themselves. Said database interaction code was\\ngenerated by \", React.createElement(_components.a, {\n    href: \"https://sqlc.dev/\"\n  }, \"sqlc\"), \", which generates database code based on a schema file\\nwritten in SQL, and a file describing SQL queries, written in SQL with some extra\\ncomments. The generated code is then wrapped up in an interface that can add\\nadditional methods for any database operations that are easier written in Go by\\ncombining other existing database queries (Creating an Item and adding it to a\\nlist at the same time, for example).\"), \"\\n\", React.createElement(_components.p, null, \"The Frontend is written in React with Typescript. The code generation happening\\nhere is with \", React.createElement(_components.a, {\n    href: \"https://www.graphql-code-generator.com/\"\n  }, \"graphql-codegen\"), \", which generates code to interface with the\\nGraphQL API and properly assign types to the response data. The rest of it is a\\nfairly standard React + Next.js app.\"), \"\\n\", React.createElement(_components.p, null, \"There is currently no live demo for Grindlists, and not all of the API functionality\\nhas been implemented in the frontend yet. However, feel free to check it out\\non GitHub, if you have Docker, docker-compose and Make, then the dev environemnt\\nsetup is pretty simple to do.\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/home/chris/source/repos/portfolio-gatsby/content/portfolio/grindlists/index.mdx\";\nimport * as React from 'react';\nimport SEO from '../../components/seo';\nconst Post = _ref => {\n  let {data, children} = _ref;\n  return React.createElement(\"div\", {\n    className: \"flex justify-center\"\n  }, React.createElement(\"div\", {\n    className: \"prose lg:prose-xl prose-zinc dark:prose-invert md:max-w-[65ch] lg:max-w-[75ch] xl:max-w-[90ch] prose-h2:mt-2 lg:prose-h2:mt-2\"\n  }, React.createElement(\"h1\", {\n    className: \"px-9 pt-9 md:px-4\"\n  }, data.mdx.frontmatter.title), React.createElement(\"div\", {\n    className: \"px-9\"\n  }, React.createElement(\"p\", null, data.mdx.frontmatter.date), children)));\n};\nconst query = \"789134884\";\nexport const Head = _ref2 => {\n  var _data$mdx$frontmatter;\n  let {data} = _ref2;\n  return React.createElement(SEO, {\n    title: data.mdx.frontmatter.title,\n    description: data.mdx.excerpt || 'nothinâ€™',\n    image: (_data$mdx$frontmatter = data.mdx.frontmatter.image) === null || _data$mdx$frontmatter === void 0 ? void 0 : _data$mdx$frontmatter.childImageSharp.sizes.src,\n    article: true\n  });\n};\nPost\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(Post, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\n","import * as React from 'react';\nimport { FunctionComponent } from 'react';\nimport { useSiteMetadata } from '../hooks/useSiteMetadata';\n\ntype SEOProps = {\n    title?: string,\n    description?: string,\n    pathname?: string,\n    article?: boolean,\n    image?: string,\n}\n\nconst SEO: FunctionComponent<SEOProps> = ({ title, description, pathname, article, image, children }) => {\n\n    const {\n        title: defaultTitle,\n        description: defaultDescription,\n        siteUrl,\n        image: defaultImage,\n        twitterUsername,\n    } = useSiteMetadata();\n\n    const seo = {\n        title: title || defaultTitle,\n        description: description || defaultDescription,\n        image: `${siteUrl}${image || defaultImage}`,\n        url: `${siteUrl}${pathname}`\n    };\n\n    return (\n        <>\n            <title>{seo.title}</title>\n            <meta name=\"description\" content={seo.description} />\n            <meta name=\"image\" content={seo.image} />\n            {seo.url && <meta property=\"og:url\" content={seo.url} />}\n            {(article ? true : null) && <meta property=\"og:type\" content=\"article\" />}\n            {seo.title && <meta property=\"og:title\" content={seo.title} />}\n            {seo.description && (\n                <meta property=\"og:description\" content={seo.description} />\n            )}\n            {seo.image && <meta property=\"og:image\" content={seo.image} />}\n            <meta name=\"twitter:card\" content=\"summary_large_image\" />\n            {twitterUsername && (\n                <meta name=\"twitter:creator\" content={twitterUsername} />\n            )}\n            {seo.title && <meta name=\"twitter:title\" content={seo.title} />}\n            {seo.description && (\n                <meta name=\"twitter:description\" content={seo.description} />\n            )}\n            {seo.image && <meta name=\"twitter:image\" content={seo.image} />}\n            {children}\n        </>\n    );\n};\n\nexport default SEO;\n","import { graphql, useStaticQuery } from \"gatsby\"\n\nexport const useSiteMetadata = () => {\n    const data = useStaticQuery(graphql`\n        query {\n            site {\n                siteMetadata {\n                    title\n                    description\n                    twitterUsername\n                    image\n                    url\n                }\n            }\n        }\n    `)\n\n    return data.site.siteMetadata;\n}\n","/**\n * @typedef {import('react').ReactNode} ReactNode\n * @typedef {import('mdx/types.js').MDXComponents} Components\n *\n * @typedef Props\n *   Configuration.\n * @property {Components | MergeComponents | null | undefined} [components]\n *   Mapping of names for JSX components to React components.\n * @property {boolean | null | undefined} [disableParentContext=false]\n *   Turn off outer component context.\n * @property {ReactNode | null | undefined} [children]\n *   Children.\n *\n * @callback MergeComponents\n *   Custom merge function.\n * @param {Components} currentComponents\n *   Current components from the context.\n * @returns {Components}\n *   Merged components.\n */\n\nimport React from 'react'\n\n/**\n * @type {import('react').Context<Components>}\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means itâ€™s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components and\n *   `MDXProvider` to set context based components instead.\n */\nexport const MDXContext = React.createContext({})\n\n/**\n * @param {import('react').ComponentType<any>} Component\n * @deprecated\n *   This export is marked as a legacy feature.\n *   That means itâ€™s no longer recommended for use as it might be removed\n *   in a future major release.\n *\n *   Please use `useMDXComponents` to get context based components instead.\n */\nexport function withMDXComponents(Component) {\n  return boundMDXComponent\n\n  /**\n   * @param {Record<string, unknown> & {components?: Components | null | undefined}} props\n   * @returns {JSX.Element}\n   */\n  function boundMDXComponent(props) {\n    const allComponents = useMDXComponents(props.components)\n    return React.createElement(Component, {...props, allComponents})\n  }\n}\n\n/**\n * Get current components from the MDX Context.\n *\n * @param {Components | MergeComponents | null | undefined} [components]\n *   Additional components to use or a function that takes the current\n *   components and filters/merges/changes them.\n * @returns {Components}\n *   Current components.\n */\nexport function useMDXComponents(components) {\n  const contextComponents = React.useContext(MDXContext)\n\n  // Memoize to avoid unnecessary top-level context changes\n  return React.useMemo(() => {\n    // Custom merge via a function prop\n    if (typeof components === 'function') {\n      return components(contextComponents)\n    }\n\n    return {...contextComponents, ...components}\n  }, [contextComponents, components])\n}\n\n/** @type {Components} */\nconst emptyObject = {}\n\n/**\n * Provider for MDX context\n *\n * @param {Props} props\n * @returns {JSX.Element}\n */\nexport function MDXProvider({components, children, disableParentContext}) {\n  /** @type {Components} */\n  let allComponents\n\n  if (disableParentContext) {\n    allComponents =\n      typeof components === 'function'\n        ? components({})\n        : components || emptyObject\n  } else {\n    allComponents = useMDXComponents(components)\n  }\n\n  return React.createElement(\n    MDXContext.Provider,\n    {value: allComponents},\n    children\n  )\n}\n"],"names":["_createMdxContent","props","_components","Object","assign","p","a","_provideComponents","components","React","href","wrapper","MDXLayout","Post","_ref","data","children","className","mdx","frontmatter","title","date","Head","_ref2","_data$mdx$frontmatter","SEO","description","excerpt","image","childImageSharp","sizes","src","article","GatsbyMDXWrapper","GATSBY_COMPILED_MDX","pathname","defaultTitle","defaultDescription","siteUrl","defaultImage","twitterUsername","useStaticQuery","site","siteMetadata","seo","url","name","content","property","MDXContext","useMDXComponents","contextComponents"],"sourceRoot":""}